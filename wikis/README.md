## Увод
Целта на този документ е да отговори различни на общи въпроси, които виждам, че аз и вие имаме при изучаването на C++.

## Стойност и референция
**Каква е разликата между подаване на променлива по стойност и подаване по референция?**
 
**Къде подавам променливата?** Подаваме променливата като параметър на дадена функция.

**Какво е стойност?** Няма по-базово понятие от "стойност" - това е нещото, което стои в клетките на паметта.
> Клетките можем да опишем чрез 2 неща - адрес и стойност.

**Какво е референция?** Тук засягаме една малко по-голяма тема, която можем да наречем "създаване на променливи". Накратко референция означава "друго име/псевдоним".

Можем да създадем **обикновена **променлива - `int x = 5;`, **указател** - `int pointerX = &x;` и **референция** - `int& y = x;`.

Променливи, които са референции, създаваме като добавим `&` след типа. Те са просто **друго име**, В този пример `y` става псевдоним на `x`, друг начин да достъпим паметта му. При създаването на `x` се заделя памет за стойността на `x`, когато направим нещо от рода на `x = 10;`, се намира адреса на клетката, на която вече отговаря `x` в нашата програма и се записва стойността `10` в нея.
Когато създадем `y` по този начин - `int& y = x;`, `y` не получава нова клетка от паметта за себе си, вместо това `x` и `y` използват една и съща клетка(или набор от клетки). Тоест, когато променим стойността на `y`, стойността на `x` също се променя. Виждали сме това поведение във функции, когато сме искали да могат да променят стойността на наша променлива.

Тук е важно да отбележим, че `&` може да се използва по различни начини - в примера с указателя, използваме `operator&`, за да вземем адреса на `x` - `int pointerX = &x;`. 

Нека сега разгледаме следния случай.
```c++
#include <iostream>

void swap(int& first, int& second)
{
    int tmp = first;
    first = second;
    second = tmp;
}

int main()
{
    int x = 5;
    int& y = x;
 
    y = 10; // x == y == 10.
 
    
    int z = 25;
    swap(x, z); // x == y == 25, z == 10.
 
    return 0;
}
```
В тази програма има 2 променливи, които в даден момент от времето са референции на `x` - `y` и `first`. Макар и `first` да е параметър на функцията `swap`, това което се случва е, че при извикването на `swap(x, z);`, не се заделя нова памет за `first` и `second`, вместо това те стават референции за подадените променливи - `x` и `z`, по тази причина след като променим стойностите на `first` и `second`, също променяме `x` и `z`, както и `y`(все пак е псевдоним на `x`), тъй като те споделят една и съща памет.

**Тогава какво се случва, когато подаваме по стойност?** Нека разгледаме друг пример, в който подаването на променливите става по стойност.
```c++
#include <iostream>

void print(int y)
{
    std::cout << y << std::endl;
}

int main()
{
    int x = 123456;
    print(x);
 
    return 0;
}

```
Има 3 реда код, който трябва да разгледаме - създаването на `x`, извикването на функцията `print` и изпълнението на `print`.
При създаването на `x` се заделя клетка от паметта, която се "именува" `x` - по някакъв начин се свързват името на променливата и адреса на клетката, така че когато използваме `x` в нашата програма да можем да използваме стойността в тази клетка.

При извикването на `print(x);` се създава нова стекова рамка, в нея всички променливи с техните стойности от `main()` са недостъпни, освен тези, които подадем като параметри - `x`. След това в новата стекова рамка се създава нова променлива `int y`, нейната стойност става стойността на `x`, вече в тялото на `print` имаме напълно различна променлива. Просто първоначалната и стойност съвпада в стойността на `x` при извикването на `print(x)`.

След като се изпълни `y = 123456`, 123456 се показва в конзолата и функцията приключва. При излизането от функцията, нейната стекова рамка се разрушава и паметта за всички нейни променливи се освобождава за повторно ползване. След това се разрушава и стековата рамка на `main()`, клетката която сме "нарекли" `x` също се освобождава и програмата приключва.

## `const ClassType& other`
При копи конструкторите и оператор= на класовете многократно виждаме неща като `const ClassType& other` - какво означава това?

Нека отново разгледаме горната функция и да видим какви биха били разликите ако променим само типа на `y` в `print`.

`void print(int& y)` - Вече си обяснихме какво се случва, `y` и `x` използват споделена памет, промяна в стойността на едната променлива, водят до промяна в другата променлива.

`void print(const int y)` - Можем да направим `y` константа променлива, добавянето на `const` не ни позволява да променяме стойността на `y` - компилаторът се грижи да не променяме `y`. Естествено това важи само за `y`, не и за `x`.
 
 Използваме същата памет както `x`, така и за `y`, но сме сложили `const` пред `y`, не ни е позволено да променяме стойността. Това е полезно, тъй като обектите, които създаваме от наши или чужди класове, могат да бъдат много обемисти, целта е скорост - не копираме всички полета, както и стойностите в тях, а само адреса чрез `&` и се подсигуряваме, че нашия код няма да променя обектите, от които копираме чрез `const`.

### Explicit & implicit casting - промяна на типа
Когато опитваме да присвоим стойност на дадена променлива и стойността е от различен тип спрямо променливата има видима или невидима промяна на типа.
При извикването на `print(x)`  се случва `implicit casting` от `int` към `const int`. `implicit` означа че се случва от езика. `casting` означава "промяна на типа". 

Например ако имаме `double z = 12.5;` Можем да кажем `int x = z; // x == 12`, това което се случва тук е същото - `implicit casting` от `double` към `int`. От друга страна можем да използваме `explicit casting` - промяна на типа, която ние изрично искаме да се случи - `int x = (int)(z + 0.5);` - закръгляне нагоре.

`int x = 12.5;` и `int x = (int)(12.5);` имат едно и също действие, разликата е, че във втория случай ние изрично сме казали към какъв тип да приеме `12.5`, преди да се изпълни присвояването.

Тъй като `const` е правило, за чието спазване следи компилаторът ни, можем спокойно да използваме `const char *` за повечето символни низове, когато пишем класове - със сигурност можем да връщаме `const char *` от нашите гетъри и да подаваме `const char *` на нашите сетъри, тъй като те нямат за цел да променят подадените. Обратната промяна на типа - от `const char *`  към `char *` не е възможна, тъй като указателя би ни позволил директно да достъпваме паметта, което би нарушило правилото, което `const` модификатора спазва. По същата причина можем да направим следното нещо
```c++
const int x = 15;
int y = x; // Valid, creates a new copy of the value in x
```
Напълно валидно, използва се стойноста на `x`, за да се създаде нова променлива - `y`. Но следния код не е позволен, тъй като референцията би използвала същата памет както константната променлива `x`. Естествено ако използваме `const reference` можем да присвоим `x`.
```c++
const int x = 15;
int& z = x; // Invalid, can't share memory with non-const variables
const int& y = x; // Perfectly fine.
```

## `const char *`, `char * const` и други
Целта на тази подсекция е да създаде интуиция за разбирането на различните типове.

* `char c` - променлива от тип `char`
* `char * name` - променлива от тип "указател към `char`
> Как да разшифроваме типа на указател? **Четем отдясно наляво** - променливата `name` e указател към **всичко наляво от звездичката**. В този случай е `char`.
* `char ** words` - променлива от тип "указател към указател, който сочи към `char`" 
> Нека го направим на стъпки - `words` е указател към `char *`, което е указател към `char`. Можем да използваме `words` за масив от думи(поредица от символи).
* `const char * name` - променлива от тип указател към константен `char` - `name` сочи някъде, но не може да променя паметта там.
* ` char const * name` - същото като горното, `char const` и `const char` за взаимнозаменяеми. 
> Следните три неща означават едно и също нещо - `const char`, ` char const`, `const char const` - използването на `const` отляво **или** отдясно на `char` води до едно и също нещо - константен `char`.
* `char * const name` - `name` е константен указател към `char` - можем да променяме стойноста в клетката, която сочим, но не можем да сочим към друга клетка, т.е. `name = otherNamePointer;` е **компилационна грешка**.
* `const char * const name = "Hello";` - `name` е константен указател към константен `char`. Не можем да променяме стойноста на на този адрес, нито къде сочи указателя. Тази променлива остава `"Hello"`, докато не бъде унищожена. 
* `const Student * student` - указател към константен обект от тип `Student` - не можем да променяме полетата на `*student`, можем да пренасочим указателя към друг константен студент.

Разгадаването на типовете не е просто тяхното наизустяване, всеки символ има някакъв смисъл зад него, след като научим различните правила, в които могат да се използват различните символи, ще можем да се оправим във всяка ситуация без проблем!